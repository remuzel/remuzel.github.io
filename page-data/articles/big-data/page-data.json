{"componentChunkName":"component---src-templates-article-js","path":"/articles/big-data","result":{"data":{"markdownRemark":{"html":"<p>This was a reaserch project proposed to two friends of mine and myself. It's all about how Big Data is a problem, and the (at the time) technologies that were being used to tackle them. If that's interesting to you, enjoy!</p>\n<hr>\n<br>\n<br>\n<h1 style=\"text-align: center;\">\nüêª with me while I copy this over!<br>In the mean time, you can read about it over at my <a href=\"https://www.doc.ic.ac.uk/~rku16/Big_Data/Home.html\" target=\"_blank\">old website</a>.\n</h1>\n<!-- \n- ## [MapReduce](#MapReduce)\n\n- ## [Tez: Better version of MapReduce](#Tez)\n\n- ## [Pig](#Pig)\n\n- ## [Hive](#Hive)\n\n- ## [Shark](#Shark)\n\n- ## [Spark SQL](#Spark-SQL)\n\n- ## [Application of Analytics](#Analytics) \n\n- ## [References](#References)\n\n<h1 class=\"is-pink\" id=\"MapReduce\">MapReduce</h1>\n\n### What is it?\n\nAs we talked about in the introduction, we‚Äôre dealing with a lot of information. That means it‚Äôs going to be expensive in either time or computational power (or both) to analyze our data. By that, I‚Äôm saying we‚Äôre going to need more than my Macbook to crack Big Data. Let‚Äôs bring out the big guns: distributed parallel computing! MapReduce: The name is relatively intuitive. You distribute the task between a lot of computers, make them run at the same time, and then regroup the results. Simple enough, right?\n\nThe next question is how to find a way to tailor parallel computing to Big Data. In 2004, Google tackled this project and made two key observations:\n\n* A lot of big data analytics is actually quite straight forward. Although you tackle huge sets of information, the data you extract can be relatively easy to work with (depending on the type of data, of course).\n* In the past, most of the parallel computing was done using Message Passing Interface. In MPI, a lot of information is passed between the parallel processes, which can be a good or bad thing depending on the situation. Therefore, observation number two is that in Big Data analytics the processes don‚Äôt really need to share information all the time. \n\nSeeing this, they set out to make an efficient program to parallelize computations that doesn‚Äôt need to lose time by sharing information between the processes[1]. MapReduce, the name given to this, will ring a bell to anyone with functional programming experience as it‚Äôs a combination of two popular functions, map, and reduce (aka fold). The name describes the program pretty well: first, the map aspect, which transforms a set of data, then a reduction.\n\nFirst, the input files are split in let‚Äôs say X pieces. Every piece is then sent to a different cluster of machines, and put into a map. This map produces key-value pairs defined by the user. Then, the key-value pairs are saved onto a local disk in a partition based on the keys. Up until now, this has been a relatively cheap computation to make. The most expensive part is called shuffling. X pieces of information have been saved on different disks so a reader has to actually go back and read everything, and then sort everything by their keys. This is because you probably want to separate the distinct keys in the upcoming reduce. If this doesn‚Äôt make sense, it will in the example. Once everything is sorted, the parallel user-defined reduce function runs and produces the final result!\n\nThese gifs examplify the MapReduce process. We used cards as an analogy. Every card is a file to be read. We only want cards that have an actual value on them. Aces, Kings, Queens, and Jacks are discarded; they are analogous to unreadable files. In this case, let's say we want to get the sum of every suit using a MapReduce. First, we'd split the cards by suit, while discarding anything with a face. Then sum things up. \n\n<br>\n\n<ul style=\"white-space: nowrap; list-style: none; display: inline;\">\n    <li style=\"list-style: none; display: inline;\">\n        <img src=\"https://www.doc.ic.ac.uk/~rku16/Big_Data/Gifs/soloMap.gif\" style=\"width:33%;\">\n    </li>\n    <li style=\"list-style: none; display: inline;\">\n        <img src=\"https://www.doc.ic.ac.uk/~rku16/Big_Data/Gifs/SplitAndMap.gif\" style=\"width:33%;\">\n    </li>\n    <li style=\"list-style: none; display: inline;\">\n        <img src=\"https://www.doc.ic.ac.uk/~rku16/Big_Data/Gifs/Shuffle.gif\" style=\"width:33%;\">\n    </li>\n</ul>\n\n<br>\n\n|                   |                          |                 |\n| :------------- |:-------------:| :-----:|\n| Here you see what it looks like when one computer tries to do the map by itself. We're only using 30 cards here so it's not that big of a deal but you can imagine the problem if we used more than 20 decks? | We now have two Nodes, or computers working on this in parallel. At the beginning we have one pile. First, we split the files, then we both do the user defined Map. | Now that we've all finished our map we do the shuffle phase, joining all the suits to allow us to do the reduction. We'll now do the simple addition. |\n\n### Advantages and shortcomings\n\nMapReduce is a rather simple parallelization paradigm. For that reason, it's great for simple calculations and data manipulations. Since every node works on different data, you can also ensure there will be no deadlock. However, it quickly becomes clear that some intricate calculations will need more than a map and a reduction. For example, working with statistics often requires a bit more than a MapReduce.\n\nAnother issue we haven't discussed yet is the initialization of a MapReduce. Splitting the files between the nodes in the beginning of the computation is slow. Furthermore, it then takes a while to get them all computing once they have their respective files. It's pretty fast after that, but if you don't have that much information to compute consider using something else. The time lost to start MapReduce might not be worth it.\n\nThere's another problem for small data sets. I'll give you a second to look back at the gifs. Can you see the issue in our 30 card example? The shuffle is slow. Look at me trying to pile the cards together; it's painful to watch! (Especially the clubs... That was cringy) It's such a small data set that we really didn't need two workers to get it done. Since shuffling is an expensive calculation, I could probably have separated the cards on my own in the same time.\n\nThere's a final aspect of MapReduce that is either an advantage or a disadvantage depending on your calculation. MapReduce is great for handling failures[2]. When a task fails on a node, MapReduce automatically sends it to another node to try and recompute it. It will do so a configurable amount of times before marking the data as a failure and tossing it away. Depending on your needs it can be good or bad. If you need a fast calculation, then it's a problem because it runs through some files multiple times. On the other, if you don't mind the delay, then it's great. You can also tweak the behaviour of how your MapReduce deals with failures. For example aborting the task if failures amount for more than an arbitrary percent of jobs, or killing process that seem to be hanging.\n\nIn short, when deciding if you're going to use MapReduce, think about how many files you have, if your calculation is simple enough, how you want to deal with failures, and your time restrictions.\n\nIf you want to check out a parallelization that was created in an attempt to get rid of the MapReduce flaws, I recommend you look at TEZ\n\n<h1 class=\"is-pink\" id=\"Tez\">Tez: Better version of MapReduce</h1>\n\n## Directed Acyclic Graphs\n\nTez uses directed acyclic graphs (DAGs) to optimize MapReduce. [3] A DAG is a graph that doesn't have directed cycles. In other terms, It's a graph in which if you move away from an vertex, you will never be able to go back. It's going to be useful to us because with it we can dictate how a program should handle different situations. This is an example of a DAG: \n\n<br>\n\n![directed_acyclic_graph](DAG.jpg)\n\n<br>\n\nAs you can see, from A, B, and E, you can make progress down but never the other way. Using a DAG, we can represent every vertex as a state, and every edge as a way to transform data to a certain state. For example, imagine A was a server log. From it, you only want to extract the IP addresses of visitors. The edge AC represents a process to do so and C is a list of IP addresses. Although B might be a different input file, in the end you also want something to do with IP addresses so both B, and C can end in F. This allows for flexibility in the input and the style of calculations, contrarily to the MapReduce paradigm.\n\nAnother difference: nothing forbids you from doing a MapReduce on top of another MapReduce. The problem with that is that it's just slow. Once you get the reduced output of the first MR, you have to re-split it to reMapReduce it. On the other hand, with TEZ and the DAG feature, you can skip the middle step. It makes more sense with a drawing:\n\n<br>\n\n![mr_v_taz](MR_vs_Tez.jpg)\n\n<br>\n\nIn the MapReduce, you see that the first mappers (blue boxes), shuffle into the two green reducers. However, before the reducers can re-Map anything, they have to store their information on the node they're currently working on. This requires effort. On the other hand, Tez can just reduce on reducers, simplifying the process.\n\n##¬†Advantages and shortcomings\n\nMapReduce is a rather rigid structure, and while Tez might seem similar, it does compensate for a few of MapReduce's shortcomings. For example, it is more flexible thanks to the DAG. It offers freedom and diversity at the cheap cost of a bit of programming. Any MapReduce can be implemented by Tez, but not all Tez processes can be simplified in terms of MapReduces.\n\nTez's flexibility does come with a drawback. Starting it takes more effort than a MapReduce, and there's a bit more processing logic in terms of the implementation. The problems of small files that we had seen in MapReduce remains as well.\n\n<h1 class=\"is-pink\" id=\"Pig\">Pig</h1>\n\n##¬†What is it?\n\nBasically, Pig (Latin) is a super-tool for MapReduce programmers. Really. It's great. It simplifies the code-writing process by giving you acess to high-level declarative querying in the spirit of SQL, and low-level, procedural programming √† la MapReduce[4].\n\nAlso, it is useful to note that Pig Latin has three, simple, yet rich data models consisting of four types:\n\n* Atom (an atomic value such as a string or number),\n* Tuple (just like in good old Haskell but with one or more values),\n* Bag (basically a list of Tuples, can contain duplicates),\n* Map (just like maps in Java, keys need to be atoms).\n\nIn general using Pig Latin instead of let's say, Java, you'll be writing 1/20th of the lines of code using 1/16th of the development time[5].\n\n## Simple steps of Pig Latin execution\n\n###¬†Specifying Input Data: LOAD\n\nThe first step of the execution of a Pig program is the LOAD operation. A step which is a tad easier than rocket-science to understand; this is where the information is parsed into Pig's data model and loaded into the program (woaah). Indeed, an input file is always assumed by the Grunt compiler to contain a sequence of tuples (i.e. a bag).\n\nTo do this, the user typically inputs:\n\n* An input text file that contains the query / data,\n* A function, usually a User Defined Function (UDF) called the deserializer,\n* An indication of the number and names of the fields to be used in the declared tuples, this is the schema.\n\nBut wait you're now thinking, \"That's a lot of things to give to Grunt! You told me just above that Pig was GREAT !... What's up with that ?\"\n\nThis is where we make our smirky faces, Grunt is pretty good and alows you to solely sprecify the text file containing the data! In this case the usualy lazy Grunt, the default deserializer is user, that expects a plain text and a tab-delimited file. The same goes for the schema information, for the default one, fields must be referred to by position rather than by name. In other words, by marking them with $0, $1, etc.\n\nNote: Grunt is lazy, in other words, no data is actually read at this point. The LOAD operation simply indicated everything the compiler will need to know in order to instantely read and process the information when the user explicitly asks for output.\n\n###¬†Per-tuple Processing: FOREACH\n\nOkay, so. At the point we have out input data file(s) specified through the LOAD instruction, all we need to know now is what to do with all this (un)valuable information. Here we will only see a basic example of operation that can he used, the FOREACH command. That of applying the same process to every element.\n\nIn general, the FOREACH command is followed by details as to what is expected to be computed from every tuple. Just like in a map function, you need to specify what you wish to map over the data set. Again, it is possible for to supply UDFs to the mapping.\n\nHere, it is often the case that we wish to flatten the information output before storing it. This involves the easily described passage from node 2 to 3 on the below diagram: \n\n<br>\n\n![Pig_FOREACH_example](Pig_FOREACH_example.png)\n\n<br>\n\n\n* Where we go from the tuple (Alice, {(lakers rumors), (lakers news)}) containing a Bag as second element.\n* to the flattend equivalent but more appealing (Alice, lakers rumors) (Alice, lakers news)\n\nNote: From the semantics of FOREACH, the input commands are understood such as there is no dependency between each processing of tuples. This furthers one of the key goals of Pig: Efficient parallel implementation. \n\n###¬†Discarding Unwanted Data: FILTER\n\nWe're almost there! There's one last step we need to go through before getting serious, the FILTER. This command is a rather \nsimple and intuitive one that does exactly what you think it does (intuitively, or after reading our great sub-title).\n\nPig Latin uses various filtering conditions including the classics such as ==, !=, logical connectors AND, OR, and NOT, as well as strict comparitors neq, and eq. But arbitrary expression are also alowed, therefore we can use UDFs while filtering.\n\n### Getting Related Data Together: COGROUP\n\nPer tuple processing only takes us so far, so we put it to you ladies and gentlemen of the jury. We usualy need to collect them in a way so that related data is grouped together such that it can be processed as a whole. This is where the COGROUP command and it's look-alikes come in action.\n\nIn general, and as in the below example, the COGROUP command returns a single tuple for each group; where the first field is always the groups' indentifier and the others are always bags in the order of which their coresponding fields was selected in the LOAD instruction. \n\nThis model naturally raises serious concerns: what about very large groups such as we see regularily in Big Data? We might end up building gigantic tuples, containing monstrous nested bags.\n\nThankfuly, in many cases it turns out the system avoids meterializing these bags (1), which is important as they can be bigger than the main memory. In the other cases, when using algebraic UDFs, Pig provides a special API to optimize these evaluations using a two-tier tree. \n\n##¬†Advantages and shortcomings\n\nThroughout these simple step by step explanations, you should already have an idea of how Pig works. To explicit certain points, here are some pros and cons of the language.\n\n###¬†Pros:\n\n* Fast developement,\n* Large optimization possibilities,\n* Efficient parallelisation implementation,\n* Reduced restrictions with regards to the input information.\n\n###¬†Cons:\n\n* Pig is terrible at processing unstructured data,\n* Memory overflow realated problems can occur when using large streams of data using non-algebraic UDFs.\n\n<h1 class=\"is-pink\" id=\"Hive\">Hive</h1>\n\n## What is it?\n\n Hive, or more precisely Apache Hive, exists to facilitate and lighten analysis of Big Data. (1)\n\nIt is a datawarehousing infrastructure built on top of Hadoop. (2)\n\nQueries can be written as statements similar to SQL. Called Hive Query Language (HQL), the language is declarative. Statements are first put into a MapReduce or Tez and then executed across a Hadoop cluster. This allows HQL to work on huge files (i.e. Big Data). (3) \n\n<h1 class=\"is-pink\" id=\"Shark\">Shark</h1>\n\n<h1 class=\"is-pink\" id=\"Spark-SQL\">Spark SQL</h1>\n\n<h1 class=\"is-pink\" id=\"Analytics\">Application of Analytics</h1>\n\n<h1 class=\"is-pink\" id=\"References\">Referencess</h1>\n\n[1]: Jeffrey Dean and Sanjay Ghemawat. Mapreduce: Simplified data processing on large clusters. Commun. ACM, 51(1):107:113, January 2008.\n\n[2]: Li, H (2015). Introduction to Big Data. New York: ADP Inovation Labs\n\n[3]: Murthy, Arun and Bikas Saha. What Is Apache Tez?. InfoQ. N.p., 2014. Web. 13 Mar. 2017.\n\n[4]: Olston, C. / Reed, B. / Srivastava, U. / Kumar, R. / Tomkins, A. (2008) Pig Latin: A Not-So-Foreign Language for Data Processing. Vancouver, Canada.\n\n[5]: YouTube. (2017). Apache Pig Tutorial 1 | Understanding Pig Latin | Pig Latin Explained | Hadoop Tutorial. [online] Available at: this link [Accessed 10 Feb. 2017]. -->","frontmatter":{"title":"The Round pegs of Big Data","desc":"Diving into what big data is, and how we're dealing with it."}}},"pageContext":{}},"staticQueryHashes":["63159454"]}